Extending Kubernetes with Go
Workshop - Gophercon Brazil 2018

André Carvalho e Cezar Sá

* Agenda

- Setup
- Concepts
- Kubernetes API basics
- Client-go
- Custom Resource Definitions (CRDs)
- Controllers
- Operators

* Requirements

This presentation and the code we are going to use is available at:

[[https://github.com/andrestc/go-kubernetes-workshop]]

We'll need:

- Go
- Minikube - For running a local kubernetes cluster
- Kubectl - For interacting with the kubernetes cluster

* Setup

- Downloading the code

  $ go get -d github.com/andrestc/go-kubernetes-workshop/...
  $ cd $GOPATH/andrestc/go-kubernetes-workshop

- Installing Minikube
  
[[https://github.com/kubernetes/minikube#installation]]

- Installing Kubectl

[[https://kubernetes.io/docs/tasks/tools/install-kubectl/]]

- Installing Operator SDK CLI (for later exercises)

[[https://github.com/operator-framework/operator-sdk/blob/master/doc/user-guide.md#install-the-operator-sdk-cli]]

* What is Kubernetes

At it's core Kubernetes is a container orchestrator.

It knows:

- *How* to start containers
- *When* to start containers
- *Where* to start containes

: One of the official definitions is "Kubernetes is an open-source system for
: automating deployment, scaling, and management of containerized applications."
: It does a lot of things not directly related to containers but containers are
: the core functionality.

: Ask if the audience is familiar with the concept of plain docker containers
: and basic explanation if needed.

* Concepts

Basic objects:

- Pods
- Services
- Endpoints
- Nodes
- ...

Kubernetes provides an API for CRUDing each available resource.

* Concepts (YAML)

Usually YAML files are used to represent a resource, example:

  apiVersion: v1
  kind: Pod
  metadata:
      name: mypod
  spec:
      containers:
        - name: mypod1
          image: busybox

* Control Plane

Resources created on the API describe the *desired* state.

The Control Plane is in an infinite loop trying to make the *desired* state a reality.

# TODO: better image
.image images/kube-arch.png _ 550
.caption By Khtan66 - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=53571935

: A YAML file with a resource description always describe a desired state,
: this desired state may never come true depending on the available resources for the
: cluster.

* Pod

Similar to docker containers, except one pod can contain more than one container.

Containers in the same pod:
- Are scheduled on the same machine;
- Share the Network namespace (same IP);
- Share volumes assigned to the Pod.

.code labs/xx-kubectl/pod.yaml

: PID namespace can also optionally be shared as of 1.10.

* Pod (2)

- Pods will die, on their own they do not provide resilience;

- A pod scheduled to a node will always run on the same node;

- A higher level abstraction is needed to provide resilience.

* Service and Endpoint

- Pods may vanish anytime their IP address will also vanish;

- Services provide a stable IP and Name to find applications on Kubernetes;

.code labs/xx-kubectl/service.yaml

* Service and Endpoint

- For each pod that matches the selector kubernetes will create an Endpoint object;

- An endpoint is only created for healthy Pod IPs.

* Manipulating objects

- API

- kubectl CLI

* Hands on

- Bootstrap minikube and check cluster

  $ minikube start
  $ kubectl cluster-info

- Manipulating resources with kubectl

  $ kubectl create -f ./labs/xx-kubectl/pod.yaml
  $ kubectl get pod
  $ kubectl create -f ./labs/xx-kubectl/service.yaml
  $ kubectl get service
  $ minikube service list

: Do a demo and then ask attendees to do the same
: Explain why minikube is used (only to get node IP)

* Controller objects

- Deployment
- ReplicaSet
- ...

* What controllers do

- Control loop that listen for changes and do something;

- Dinamically create or manipulate basic objects;

- Built-in controllers are implemented in the `controller-manager` component.

- The scheduler is also a controller:
-    Watch for created pods;
-    Assigns a node to the pod.

: The workshop will focus on controllers from now on. After taking a look
: at built-in controllers we'll work further on creating our own controller.

* Deployment

.code labs/xx-kubectl/deployment.yaml

* Create deployment with kubectl

  $ kubectl create -f ./labs/xx-kubectl/deployment.yaml
  $ kubectl get pod,deployment,replicaset

- Deployments manage the pod lifecycle;
- Ensure the number of replica pods exist;
- If a node is down a new pod will be created to replace the missing one;
- Manages rolling update of new pod templates.

* ReplicaSet

- Does most of the work for the deployment controller, except rolling updates;
- It's not usually created manually.

* What does the controller do

Deployment controller

- Watches for deployment object to appear;
- Creates a new replicaSet object every time the template field is changed;
- Updates the old replicaSet replicas count to zero.

ReplicaSet controller

- Watches for replica set objects;
- Create new pods matching the number of replica pods;
- Watches for pods matching the selector labels;
- If a pod dies creates a new one to replace it.

: Clarify this is an overly simplified explanation

* Let's make a simple controller

  $ kubectl get pod --no-headers --watch-only -o 'go-template={{println .metadata.name}}' \
    | xargs -I{} kubectl label pod {} ack=true &

  $ kubectl get pod mypod --show-labels
  NAME      READY     STATUS    RESTARTS   AGE       LABELS
  mypod     1/1       Running   0          4d        app=myapp

  $ kubectl label pod mypod a=b

  $ kubectl get pod mypod --show-labels
  NAME      READY     STATUS    RESTARTS   AGE       LABELS
  mypod     1/1       Running   0          4d        a=b,ack=true,app=myapp

* Kubernetes API basics

  $ kubectl proxy

[[http://127.0.0.1:8001/openapi/v2]]

* Kubernetes API basics

Core objects:

- /api/<version>/<resource>
- [[http://127.0.0.1:8001/][/]]
- [[http://127.0.0.1:8001/api][/api]]
- [[http://127.0.0.1:8001/api/v1][/api/v1]]
- [[http://127.0.0.1:8001/api/v1/pods][/api/v1/pods]]

With namespaces:

- /api/<version>/<namespaces>/<namespace name>/<resource>
- [[http://127.0.0.1:8001/api/v1/namespaces/default/pods][/api/v1/namespaces/default/pods]]
- [[http://127.0.0.1:8001/api/v1/namespaces/default/pods/mypod][/api/v1/namespaces/default/pods/mypod]]

: Highlight verbs in /api/v1 call for pods

* Kubernetes API basics (2)

Non-core objects:

- /apis/<group>/<version>/<resource>
- [[http://127.0.0.1:8001/apis][/apis]]
- [[http://127.0.0.1:8001/apis/apps/v1][/apis/apps/v1]]
- [[http://127.0.0.1:8001/apis/apps/v1/deployments][/apis/apps/v1/deployments]]

With namespaces:

- /apis/<group>/<version>/<namespaces>/<namespace name>/<resource>
- [[http://127.0.0.1:8001/apis/apps/v1/namespaces/default/deployments][/apis/apps/v1/deployments]]
- [[http://127.0.0.1:8001/apis/apps/v1/namespaces/default/deployments/nginx-deployment][/apis/apps/v1/deployments/nginx-deployment]]

* Kubernetes API basics (3)

My kubernetes, my group, my resource, my rules.

Custom Resource Definitions (CRDs):

- /apis/<my group>/<my version>/<my resource>

* Kubernetes API

Let's create a new pod using the API

  $ curl -XPOST http://127.0.0.1:8001/api/v1/namespaces/default/pods \
    -H "Content-Type: application/json" -d \
    '{"apiVersion": "v1", "kind": "Pod", "metadata": {"name": "mypod2"},
      "spec": {"containers": [{"name": "mycont","image": "nginx"}]}}'

* Tasks API

TODO

* Client-go

.code labs/01-client-go/main.go /START1 OMIT/,/END1 OMIT/

.code labs/01-client-go/main.go /START2 OMIT/,/END2 OMIT/

* Custom Resource Definitions (CRDs)

* Custom Resource Definitions (CRDs)

We can use Kubernetes to store custom objects called Custom Resources
  
  apiVersion: samplecontroller.k8s.io/v1alpha1
  kind: Foo
  metadata:
    name: example-foo
  spec:
    deploymentName: example-foo
    replicas: 1

Custom resources are defined by a Custom Resource Definition

  apiVersion: apiextensions.k8s.io/v1beta1
  kind: CustomResourceDefinition
  metadata:
    name: foos.samplecontroller.k8s.io
  spec:
    group: samplecontroller.k8s.io
    version: v1alpha1
    names:
      kind: Foo
      plural: foos
    scope: Namespaced

* CRDs - Validation

  apiVersion: apiextensions.k8s.io/v1beta1
  kind: CustomResourceDefinition
  metadata:
    name: foos.samplecontroller.k8s.io
  spec:
    group: samplecontroller.k8s.io
    version: v1alpha1
    names:
      kind: Foo
      plural: foos
    scope: Namespaced
    validation:
      openAPIV3Schema:
        properties:
          spec:
            properties:
              replicas:
                type: integer
                minimum: 1
                maximum: 10


* CRDs - Hands On

- Apply the CRD yaml to your Kubernetes cluster

  kubectl apply -f labs/02-controllers/artifacts/examples/crd.yaml

- Create a few Custom Resources

  kubectl apply -f labs/02-controllers/artifacts/examples/example-foo/yaml

- Add some validation to your CRD, e.g, replicas must be a integer

* CRDs - Programmatically

*pkg/apis/samplecontroller/v1alpha1/types.go*

.code examples/xx-crds/types.go /START 01/,/FINISH 01/

* CRDs - Programmatically

*pkg/apis/samplecontroller/v1alpha1/types.go*

.code examples/xx-crds/types.go /START 02/,/FINISH 02/

* CRDs - Programmatically

*pkg/apis/samplecontroller/v1alpha1/register.go*

.code examples/xx-crds/register.go /START 01/,/FINISH 01/

* CRDs - Programmatically

*pkg/apis/samplecontroller/v1alpha1/register.go*

.code examples/xx-crds/register.go /START 02/,/FINISH 02/

* CRDs - Programmatically

*pkg/apis/samplecontroller/register.go*

.code examples/xx-crds/outer_register.go

* CRDs - Programmatically

Bash script to generate boilerplate code based on the annotations

  hack/update-codegen.sh

Bash script to verify code is updated

  hack/verify-codegen.sh

Depends on k8s.io/code-generator (tricky to vendor with dep)

* Controllers

* Controllers - Basics

1. *Watch* for changes in the Kubernetes API (Informers, Watch)
2. *Update* other Kubernetes API resources
3. *Update* on other real world objects (APIs, Infrastructure)
4. *Repeat*

* Controllers - Basics

.image images/controllers-1.jpeg _ 700
.caption https://medium.com/@cloudark/kubernetes-custom-controllers-b6c7d0668fdf

* Sample Controller

Creates a *Deployment* for each *Foo*

    apiVersion: samplecontroller.k8s.io/v1alpha1
    kind: Foo
    metadata:
      name: example-foo
    spec:
      deploymentName: example-foo
      replicas: 1

.link https://github.com/kubernetes/sample-controller

* Sample Controller

  ├── hack
  └── pkg
      ├── apis
      │   └── samplecontroller
      │       └── v1alpha1
      ├── client
      │   ├── clientset
      │   │   └── versioned
      │   │       ├── fake
      │   │       ├── scheme
      │   │       └── typed
      │   │           └── samplecontroller
      │   │               └── v1alpha1
      │   │                   └── fake
      │   ├── informers
      │   │   └── externalversions
      │   │       ├── internalinterfaces
      │   │       └── samplecontroller
      │   │           └── v1alpha1
      │   └── listers
      │       └── samplecontroller
      │           └── v1alpha1
      └── signals


* Sample Controller - main.go

.code -numbers examples/02-controllers/main.go /START 01/,/FINISH 01/

* Sample Controller - main.go

.code -numbers examples/02-controllers/main.go /START 02/,/FINISH 02/

* Sample Controller - controller.go

.code -numbers examples/02-controllers/controller.go /START 01/,/FINISH 01/

.code -numbers examples/02-controllers/controller.go /enqueueFoo\(obj interface\{\}\)/,/^}/

.code -numbers examples/02-controllers/controller.go /runWorker\(\)/,/^}/

* Sample Controller - controller.go

.code -numbers examples/02-controllers/controller.go /\) processNextWorkItem/,/\) processNextWorkItem/

.code -numbers examples/02-controllers/controller.go /START PROCESS/,/FINISH PROCESS/

.code -numbers examples/02-controllers/controller.go /START PROCESS-02/,/FINISH PROCESS-02/

* Sample Controller - controller.go

.code -numbers examples/02-controllers/controller.go /START 02/,/FINISH 02/

* Sample Controller - controllers.go

.code -numbers examples/02-controllers/controller.go /\) handleObject/,/\) handleObject/

.code -numbers examples/02-controllers/controller.go /START HANDLE-01/,/FINISH/

* Sample Controller - controllers.go

.code -numbers examples/02-controllers/controller.go /START HANDLE-02/,/FINISH/

* Hands On - Controller

.link github.com/andrestc/go-kubernetes-workshop/labs/02-controllers

- Change the sample controller to also maintain a *Service* for each *Foo*

- The user should be able to choose between *ClusterIP* and *NodePort*

- Update *Foo* status to show the *Service*'s IP

* Controllers - References

.link https://github.com/kubernetes/sample-controller
.link https://kccnceu18.sched.com/event/DqvN/writing-kube-controllers-for-everyone-maciej-szulik-red-hat-beginner-skill-level
.link https://medium.com/@cloudark/kubernetes-custom-controllers-b6c7d0668fdf
.link https://github.com/kubernetes/kubernetes/tree/master/pkg/controller


* Operators

* Operators - References

.link https://github.com/operator-framework/operator-sdk
.link https://banzaicloud.com/blog/operator-sdk/
.link https://robszumski.com/building-an-operator/